"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultTypeFormatFlags = exports.getText = exports.getIdentifierFromExpression = exports.getNameFromExpression = exports.getDecoratorName = void 0;
const tss = require("typescript/lib/tsserverlibrary");
const is_dynamically_added_util_1 = require("./is-dynamically-added.util");
function getDecoratorName(decorator) {
    const isDecoratorFactory = decorator.expression.kind === tss.SyntaxKind.CallExpression;
    if (isDecoratorFactory) {
        const callExpression = decorator.expression;
        const expression = callExpression.expression;
        const identifier = expression;
        if ((0, is_dynamically_added_util_1.isDynamicallyAdded)(identifier)) {
            return undefined;
        }
        return getIdentifierFromExpression(expression).getText();
    }
    return getIdentifierFromExpression(decorator.expression).getText();
}
exports.getDecoratorName = getDecoratorName;
function getNameFromExpression(expression) {
    if (expression &&
        expression.kind === tss.SyntaxKind.PropertyAccessExpression) {
        return expression.name;
    }
    return expression;
}
exports.getNameFromExpression = getNameFromExpression;
function getIdentifierFromExpression(expression) {
    const identifier = getNameFromExpression(expression);
    if (identifier && identifier.kind !== tss.SyntaxKind.Identifier) {
        throw new Error();
    }
    return identifier;
}
exports.getIdentifierFromExpression = getIdentifierFromExpression;
function getText(type, typeChecker, enclosingNode, typeFormatFlags) {
    if (!typeFormatFlags) {
        typeFormatFlags = getDefaultTypeFormatFlags(enclosingNode);
    }
    const compilerNode = !enclosingNode ? undefined : enclosingNode;
    return typeChecker.typeToString(type, compilerNode, typeFormatFlags);
}
exports.getText = getText;
function getDefaultTypeFormatFlags(enclosingNode) {
    let formatFlags = tss.TypeFormatFlags.UseTypeOfFunction |
        tss.TypeFormatFlags.NoTruncation |
        tss.TypeFormatFlags.UseFullyQualifiedType |
        tss.TypeFormatFlags.WriteTypeArgumentsOfSignature;
    if (enclosingNode &&
        enclosingNode.kind === tss.SyntaxKind.TypeAliasDeclaration)
        formatFlags |= tss.TypeFormatFlags.InTypeAlias;
    return formatFlags;
}
exports.getDefaultTypeFormatFlags = getDefaultTypeFormatFlags;
//# sourceMappingURL=get.util.js.map