"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelVisitor = void 0;
const classes_1 = require("@automapper/classes");
const tsserverlibrary_1 = require("typescript/lib/tsserverlibrary");
const ast_utils_1 = require("./ast-utils");
const constants_1 = require("./constants");
const plugin_utils_1 = require("./plugin-utils");
class ModelVisitor {
    static reset() {
        this.metadataMap.clear();
        this.importsMap.clear();
        this.isCommonJS = false;
    }
    static visit(sourceFile, context, program) {
        const typeChecker = program.getTypeChecker();
        ModelVisitor.isCommonJS =
            context.getCompilerOptions().module === tsserverlibrary_1.ModuleKind.CommonJS;
        function visitor(ctx, sf) {
            const _visitor = (node) => {
                if ((0, tsserverlibrary_1.isImportDeclaration)(node)) {
                    ModelVisitor.importsMap.set(node.moduleSpecifier.text, ModelVisitor.cloneImportDeclaration(ctx.factory, node));
                    return node;
                }
                if ((0, tsserverlibrary_1.isClassDeclaration)(node)) {
                    node = (0, tsserverlibrary_1.visitEachChild)(node, _visitor, ctx);
                    return ModelVisitor.addMetadataFactory(node, ctx.factory);
                }
                if ((0, tsserverlibrary_1.isPropertyDeclaration)(node) || (0, tsserverlibrary_1.isGetAccessorDeclaration)(node)) {
                    const decorators = node.decorators;
                    const existingAutoMapDecorator = (0, plugin_utils_1.getDecoratorOrUndefinedByNames)([constants_1.AUTOMAPPER_DECORATOR_NAME], ctx.factory, decorators);
                    if (existingAutoMapDecorator) {
                        return node;
                    }
                    const isPropertyStaticOrPrivate = (node.modifiers || []).some((modifier) => modifier.kind === tsserverlibrary_1.SyntaxKind.StaticKeyword ||
                        modifier.kind === tsserverlibrary_1.SyntaxKind.PrivateKeyword);
                    if (isPropertyStaticOrPrivate) {
                        return node;
                    }
                    if (node['jsDoc']) {
                        const ignoreTag = (0, tsserverlibrary_1.getAllJSDocTags)(node['jsDoc'], (tag) => tag.tagName.escapedText === 'autoMapIgnore');
                        if (ignoreTag) {
                            return node;
                        }
                    }
                    ModelVisitor.inspectNode(ctx.factory, node, typeChecker, ctx.factory.createNodeArray(), sf);
                    return node;
                }
                return (0, tsserverlibrary_1.visitEachChild)(node, _visitor, ctx);
            };
            return _visitor;
        }
        const _sourceFile = (0, tsserverlibrary_1.visitNode)(sourceFile, visitor(context, sourceFile));
        if (ModelVisitor.isCommonJS) {
            return _sourceFile;
        }
        return context.factory.updateSourceFile(_sourceFile, [...ModelVisitor.importsMap.values()].concat((_sourceFile.statements || []).filter((statement) => statement.kind !== tsserverlibrary_1.SyntaxKind.ImportDeclaration)), _sourceFile.isDeclarationFile, _sourceFile.referencedFiles, _sourceFile.typeReferenceDirectives, _sourceFile.hasNoDefaultLib, _sourceFile.libReferenceDirectives);
    }
    static addMetadataFactory(classNode, factory) {
        const classMetadata = this.getClassMetadata(classNode);
        if (!classMetadata) {
            return classNode;
        }
        const returnValue = factory.createArrayLiteralExpression(Object.entries(classMetadata).reduce((expressions, [key, val]) => {
            if (val) {
                expressions.push(factory.createArrayLiteralExpression([
                    factory.createStringLiteral(key),
                    factory.createObjectLiteralExpression(ModelVisitor.getMetadataObjectLiteralExpression(factory, val.initializer)),
                ]));
            }
            return expressions;
        }, []));
        const method = factory.createMethodDeclaration(undefined, [factory.createModifier(tsserverlibrary_1.SyntaxKind.StaticKeyword)], undefined, factory.createIdentifier(classes_1.AUTOMAPPER_METADATA_FACTORY_KEY), undefined, undefined, [], undefined, factory.createBlock([factory.createReturnStatement(returnValue)], true));
        return factory.updateClassDeclaration(classNode, classNode.decorators, classNode.modifiers, classNode.name, classNode.typeParameters, classNode.heritageClauses, [...classNode.members, method]);
    }
    static getMetadataObjectLiteralExpression(factory, arrowFn) {
        var _a;
        const properties = [
            factory.createPropertyAssignment('typeFn', arrowFn),
        ];
        const arrowFnBodyText = (_a = arrowFn.body) === null || _a === void 0 ? void 0 : _a.text;
        if (arrowFnBodyText &&
            (arrowFnBodyText === String.name ||
                arrowFnBodyText === Number.name ||
                arrowFnBodyText === Boolean.name ||
                arrowFnBodyText === Date.name ||
                arrowFnBodyText === 'null')) {
            return properties;
        }
        return properties.concat(factory.createPropertyAssignment('depth', factory.createNumericLiteral(0)));
    }
    static getClassMetadata(classNode) {
        if (!classNode.name) {
            return;
        }
        return this.metadataMap.get(classNode.name.getText());
    }
    static addClassMetadata(propertyNode, objectLiteral, sourceFile) {
        var _a, _b;
        const hostClass = propertyNode.parent;
        const className = (_a = hostClass.name) === null || _a === void 0 ? void 0 : _a.getText();
        if (!className) {
            return;
        }
        const existingMetadata = this.metadataMap.get(className) || {};
        const propertyName = (_b = propertyNode.name) === null || _b === void 0 ? void 0 : _b.getText(sourceFile);
        if (!propertyName ||
            (propertyNode.name &&
                propertyNode.name.kind === tsserverlibrary_1.SyntaxKind.ComputedPropertyName)) {
            return;
        }
        this.metadataMap.set(className, Object.assign(Object.assign({}, existingMetadata), { [propertyName]: objectLiteral.properties[0] }));
    }
    static inspectNode(factory, node, typeChecker, existingProperties = factory.createNodeArray(), sourceFile) {
        const properties = [
            ...existingProperties,
            ModelVisitor.createPropertyAssignment(node, typeChecker, existingProperties, sourceFile.fileName, factory),
        ];
        const objectLiteral = factory.createObjectLiteralExpression(properties
            .reduce((a, b) => a.concat(b), [])
            .filter(Boolean));
        this.addClassMetadata(node, objectLiteral, sourceFile);
    }
    static createPropertyAssignment(node, typeChecker, existingProperties, hostFileName, factory) {
        var _a;
        const key = (_a = node.name) === null || _a === void 0 ? void 0 : _a.getText();
        if (!key || (0, ast_utils_1.hasPropertyKey)(key, existingProperties)) {
            return undefined;
        }
        let type = typeChecker.getTypeAtLocation(node);
        if (!type) {
            return undefined;
        }
        if ((0, ast_utils_1.isNullableUnionType)(type)) {
            type = type.getNonNullableType();
        }
        if (this.shouldCreateNullNode(type, typeChecker, node)) {
            return factory.createPropertyAssignment(key, factory.createArrowFunction(undefined, undefined, [], undefined, undefined, factory.createNull()));
        }
        let typeReference = (0, plugin_utils_1.getTypeReferenceAsString)(type, typeChecker);
        if (!typeReference) {
            typeReference = this.tryGetTypeReferenceFromNodeType(node);
        }
        if (!typeReference) {
            return undefined;
        }
        if (typeReference.includes('import')) {
            if (ModelVisitor.isCommonJS) {
                typeReference = (0, plugin_utils_1.replaceImportPath)(typeReference, hostFileName);
            }
            else {
                typeReference = typeReference.split('.').pop();
            }
        }
        return this.createArrowFunctionWithTypeReference(factory, key, typeReference);
    }
    static tryGetTypeReferenceFromNodeType(node) {
        var _a;
        return (_a = node.type.typeName) === null || _a === void 0 ? void 0 : _a.escapedText;
    }
    static createArrowFunctionWithTypeReference(factory, key, typeReference) {
        return factory.createPropertyAssignment(key, factory.createArrowFunction(undefined, undefined, [], undefined, undefined, factory.createIdentifier(typeReference)));
    }
    static cloneImportDeclaration(factory, importDeclaration) {
        return factory.createImportDeclaration(importDeclaration.decorators, importDeclaration.modifiers, importDeclaration.importClause, importDeclaration.moduleSpecifier);
    }
    static shouldCreateNullNode(type, typeChecker, node) {
        return (0, ast_utils_1.isTypeLiteral)(type) || (0, ast_utils_1.isAnyType)(type, typeChecker, node);
    }
}
exports.ModelVisitor = ModelVisitor;
ModelVisitor.metadataMap = new Map();
ModelVisitor.importsMap = new Map();
ModelVisitor.isCommonJS = false;
//# sourceMappingURL=model-visitor.js.map