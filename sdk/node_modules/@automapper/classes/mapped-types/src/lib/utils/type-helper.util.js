"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inheritPropertyInitializers = exports.inheritAutoMapMetadata = void 0;
const classes_1 = require("@automapper/classes");
function inheritAutoMapMetadata(parentClass, 
// eslint-disable-next-line @typescript-eslint/ban-types
targetClass, isPropertyInherited) {
    try {
        const parentClassMetadataList = (0, classes_1.getMetadataList)(parentClass);
        if (!parentClassMetadataList.length) {
            return;
        }
        const existingMetadataList = (0, classes_1.getMetadataList)(targetClass);
        Reflect.defineMetadata(classes_1.AUTOMAP_PROPERTIES_METADATA_KEY, [
            ...existingMetadataList,
            ...parentClassMetadataList.filter(([propertyKey]) => !isPropertyInherited || isPropertyInherited(propertyKey)),
        ], targetClass);
    }
    catch (e) {
        console.error(e);
    }
}
exports.inheritAutoMapMetadata = inheritAutoMapMetadata;
function inheritPropertyInitializers(target, sourceClass, isPropertyInherited = () => true) {
    try {
        const tempInstance = new sourceClass();
        const propertyNames = Object.getOwnPropertyNames(tempInstance);
        propertyNames
            .filter((propertyName) => typeof tempInstance[propertyName] !== 'undefined' &&
            typeof target[propertyName] === 'undefined')
            .filter((propertyName) => isPropertyInherited(propertyName))
            .forEach((propertyName) => {
            target[propertyName] = tempInstance[propertyName];
        });
    }
    catch (e) {
        console.error('Error inheriting properties');
    }
}
exports.inheritPropertyInitializers = inheritPropertyInitializers;
//# sourceMappingURL=type-helper.util.js.map