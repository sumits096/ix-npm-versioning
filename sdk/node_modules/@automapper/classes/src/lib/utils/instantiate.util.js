"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instantiate = void 0;
const core_1 = require("@automapper/core");
/**
 * Recursively instantiate a model with its metadata
 *
 * @param {ClassInstanceStorage} instanceStorage
 * @param {ClassMetadataStorage} metadataStorage
 * @param {Constructible} model
 * @param {TModel} defaultValue
 */
function instantiate(instanceStorage, metadataStorage, model, defaultValue) {
    // get the metadata of the model
    const metadata = metadataStorage.getMetadata(model);
    // instantiate a model with/without defaultValue
    const instance = defaultValue
        ? Object.assign(new model(), defaultValue)
        : new model();
    // if metadata is empty, return the instance early
    if ((0, core_1.isEmpty)(metadata) || !metadata) {
        return [instance];
    }
    // initialize a nestedConstructible with empty []
    const nestedConstructible = [];
    for (let i = 0, metadataLen = metadata.length; i < metadataLen; i++) {
        // destructure
        const [key, meta, isGetterOnly] = metadata[i];
        // skip getter only completely
        if (isGetterOnly) {
            continue;
        }
        // get the value at the current key
        const valueAtKey = (0, core_1.get)(instance, key);
        // call the meta fn to get the metaResult of the current key
        const metaResult = meta();
        // push to nestedConstructible
        nestedConstructible.push([key, metaResult]);
        // if is String, Number, Boolean, Array, assign valueAtKey or undefined
        // null meta means this has any type or an arbitrary object, treat as primitives
        if ((0, core_1.isPrimitiveConstructor)(metaResult) || metaResult === null) {
            const value = (0, core_1.isDefined)(valueAtKey, true) ? valueAtKey : undefined;
            (0, core_1.setMutate)(instance, key, value);
            continue;
        }
        // if is Date, assign a new Date value if valueAtKey is defined, otherwise, undefined
        if ((0, core_1.isDateConstructor)(metaResult)) {
            const value = (0, core_1.isDefined)(valueAtKey)
                ? Array.isArray(valueAtKey)
                    ? [...valueAtKey]
                    : new Date(valueAtKey)
                : undefined;
            (0, core_1.setMutate)(instance, key, value);
            continue;
        }
        // if the value at key is an array
        if (Array.isArray(valueAtKey)) {
            // loop through each value and recursively call instantiate with each value
            const value = valueAtKey.map((val) => {
                const [instantiateResultItem] = instantiate(instanceStorage, metadataStorage, metaResult, val);
                return instantiateResultItem;
            });
            (0, core_1.setMutate)(instance, key, value);
            continue;
        }
        // if value is not null/undefined
        if ((0, core_1.isDefined)(valueAtKey)) {
            // instantiate with value at key
            const [definedInstantiateResult] = instantiate(instanceStorage, metadataStorage, metaResult, valueAtKey);
            (0, core_1.setMutate)(instance, key, definedInstantiateResult);
            continue;
        }
        // if value is null/undefined but defaultValue is not
        // should assign straightaway
        if ((0, core_1.isDefined)(defaultValue)) {
            (0, core_1.setMutate)(instance, key, valueAtKey);
            continue;
        }
        // get depth and count of the current key on the current model
        // Eg: Foo {bar: Bar}, model here is Foo and key is bar
        const [depth, count = 0] = instanceStorage.getDepthAndCount(model, key);
        // if no depth, just instantiate with new keyword without recursive
        if (depth === 0) {
            (0, core_1.setMutate)(instance, key, new metaResult());
            continue;
        }
        // if depth equals count, meaning instantiate has run enough loop.
        // reset the count then assign with new keyword
        if (depth === count) {
            instanceStorage.resetCount(model, key);
            (0, core_1.setMutate)(instance, key, new metaResult());
            continue;
        }
        // increment the count and recursively call instantiate
        instanceStorage.setCount(model, key, (0, core_1.isDefined)(count) ? count + 1 : 1);
        const [instantiateResult] = instantiate(instanceStorage, metadataStorage, metaResult);
        (0, core_1.setMutate)(instance, key, instantiateResult);
    }
    // after all, resetAllCount on the current model
    instanceStorage.resetAllCount(model);
    // return instance and the nestedConstructible array
    return [instance, nestedConstructible];
}
exports.instantiate = instantiate;
//# sourceMappingURL=instantiate.util.js.map