"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.classes = void 0;
const core_1 = require("@automapper/core");
require("reflect-metadata");
const storages_1 = require("./storages");
const utils_1 = require("./utils");
/**
 *
 * A MapPlugin to work with JS/TS Classes.
 *
 * @param {ErrorHandler} errorHandler
 */
const classes = (errorHandler) => {
    // Initialize all the storages
    const metadataStorage = new storages_1.ClassMetadataStorage();
    const mappingStorage = new storages_1.ClassMappingStorage();
    const instanceStorage = new storages_1.ClassInstanceStorage();
    return {
        instantiate(model, obj) {
            return (0, utils_1.instantiate)(instanceStorage, metadataStorage, model, obj);
        },
        initializeMapping(source, destination, options) {
            // If a mapping already exists, handle error and return;
            if (mappingStorage.has(source, destination)) {
                errorHandler.handle(`Mapping for source ${source.name} and destination ${destination.name} already exists`);
                return;
            }
            // Run the source and destination through Reflection to update storages
            // with information/metadata about source and destination
            (0, utils_1.exploreMetadata)(metadataStorage, instanceStorage, source, destination);
            /**
             * Instantiate a new instance of Destination/Source along with any nested constructible
             *
             * ```ts
             * Foo {
             *   bar: Bar;
             * }
             * ```
             * `Foo#bar` is a nested constructible
             */
            const [destinationInstance, destinationNestedConstructible] = this.instantiate(destination);
            const [sourceInstance, sourceNestedConstructible] = this.instantiate(source);
            // Get a hold of the prototype of Source (in case of inheritance with extends keyword)
            const sourceProto = Object.getPrototypeOf(source);
            // Call `createInitialMapping` from the core package
            return (0, core_1.createInitialMapping)(sourceInstance, destinationInstance, sourceNestedConstructible, destinationNestedConstructible, (mapping) => {
                mapping[1 /* keys */] = [source, destination];
                mappingStorage.set(source, destination, mapping);
            }, options, {
                // classes plugin needs to pre-process the prototype of Source
                // before looping through the properties on the Destination
                prePropertiesLoop: (0, utils_1.prePropertiesLoop)(source, metadataStorage, instanceStorage, sourceInstance, sourceNestedConstructible),
                isMetadataNullAtKey: (key) => {
                    return metadataStorage.getMetadataForKey(destination, key) === null;
                },
                // classes plugin needs to check for sourcePaths on the prototype of Source
                isMultipartSourcePathsInSource: (multipartSourcePaths, sourceObj) => (0, utils_1.isMultipartSourcePathsInSource)(multipartSourcePaths, sourceObj),
                // classes plugin needs to check for the destinationPath (sourcePath) on the prototype of Source
                isDerivedSourcePathOnSource: (0, utils_1.isDerivedSourcePathOnSourceClasses)(sourceProto),
            });
        },
        getMapping(source, destination) {
            // get mapping of source and destination from mappingStorage
            const mapping = mappingStorage.get(source, destination);
            // handle error and fail fast if not found
            if (!mapping) {
                errorHandler.handle(`Mapping not found for source ${source.name} and destination ${destination.name}`);
                return;
            }
            // run preMap to get new instances of source and destination for mapping[MappingClassId.mappings]
            // this is to prevent mutation
            mapping[0 /* mappings */] = this.preMap(source, destination);
            // return the mapping
            return mapping;
        },
        preMap(source, destination, sourceObj, destinationObj) {
            // Prepare the sourceInstance/destinationInstance with plain object sourceObj and destinationObj
            const [sourceInstance] = this.instantiate(source, sourceObj);
            const [destinationInstance] = this.instantiate(destination, destinationObj);
            return [sourceInstance, destinationInstance];
        },
        dispose() {
            metadataStorage.dispose();
            mappingStorage.dispose();
            instanceStorage.dispose();
        },
    };
};
exports.classes = classes;
//# sourceMappingURL=classes.js.map