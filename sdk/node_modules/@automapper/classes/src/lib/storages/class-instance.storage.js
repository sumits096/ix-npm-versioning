"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassInstanceStorage = void 0;
const DATA_SYMBOL = Symbol('map-data');
/**
 * Internal ClassInstanceStorage
 *
 * This is to store recursive depth and recursive count of circular deps models
 * Not test due to private
 *
 * @private
 */
class ClassInstanceStorage {
    constructor() {
        this.depthStorage = new WeakMap();
        this.recursiveCountStorage = new WeakMap();
    }
    getDepthAndCount(parent, member) {
        return [this.getDepth(parent, member), this.getCount(parent, member)];
    }
    getDepth(parent, member) {
        return ClassInstanceStorage.getInternal(this.depthStorage, parent, member);
    }
    getCount(parent, member) {
        return ClassInstanceStorage.getInternal(this.recursiveCountStorage, parent, member);
    }
    setDepth(parent, member, depth) {
        ClassInstanceStorage.setInternal(this.depthStorage, parent, member, depth);
    }
    setCount(parent, member, count) {
        ClassInstanceStorage.setInternal(this.recursiveCountStorage, parent, member, count);
    }
    resetCount(parent, member) {
        this.setCount(parent, member, 0);
    }
    resetAllCount(parent) {
        const count = this.recursiveCountStorage.get(parent);
        if (count) {
            count.clear();
        }
    }
    dispose() {
        this.recursiveCountStorage = new WeakMap();
        this.depthStorage = new WeakMap();
    }
    static getInternal(storage, parent, member) {
        const parentVal = storage.get(parent);
        return parentVal ? arrayMapGet(parentVal, member) : undefined;
    }
    static setInternal(storage, parent, member, value) {
        if (!storage.has(parent)) {
            storage.set(parent, arrayMapSet(new Map(), member, value));
            return;
        }
        if (!this.hasInternal(storage, parent, member)) {
            arrayMapSet(storage.get(parent), member, value);
        }
    }
    static hasInternal(storage, parent, member) {
        const parentVal = storage.get(parent);
        return parentVal ? arrayMapHas(parentVal, member) : false;
    }
}
exports.ClassInstanceStorage = ClassInstanceStorage;
function arrayMapSet(root, path, value) {
    let map = root;
    for (const item of path) {
        let nextMap = map.get(item);
        if (!nextMap) {
            // Create next map if none exists
            nextMap = new Map();
            map.set(item, nextMap);
        }
        map = nextMap;
    }
    // Reached end of path.  Set the data symbol to the given value
    map.set(DATA_SYMBOL, value);
    return root;
}
function arrayMapHas(root, path) {
    let map = root;
    for (const item of path) {
        const nextMap = map.get(item);
        if (nextMap) {
            map = nextMap;
        }
        else {
            return false;
        }
    }
    return map.has(DATA_SYMBOL);
}
function arrayMapGet(root, path) {
    let map = root;
    for (const item of path) {
        map = map.get(item);
        if (!map)
            return undefined;
    }
    return map.get(DATA_SYMBOL);
}
//# sourceMappingURL=class-instance.storage.js.map