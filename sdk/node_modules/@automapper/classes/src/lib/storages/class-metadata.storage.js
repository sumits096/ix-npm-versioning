"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassMetadataStorage = void 0;
const core_1 = require("@automapper/core");
/**
 * Internal ClassMetadataStorage
 *
 * This is to store Metadata of all the models using ReflectMetadata
 * Not test due to private
 *
 * @private
 */
class ClassMetadataStorage {
    constructor() {
        this.storage = new WeakMap();
    }
    getMetadata(model) {
        var _a;
        const metadataList = (_a = this.storage.get(model)) !== null && _a !== void 0 ? _a : [];
        // empty metadata
        if (!metadataList.length) {
            // try to get the metadata on the prototype of the class
            return model.name ? this.getMetadata(Object.getPrototypeOf(model)) : [];
        }
        const resultMetadataList = [];
        for (let i = 0, metadataListLen = metadataList.length; i < metadataListLen; i++) {
            const metadata = metadataList[i];
            // skip existing
            if (resultMetadataList.some(([metaKey]) => (0, core_1.isSamePath)(metaKey, metadata[0]))) {
                continue;
            }
            resultMetadataList.push(metadataList[i]);
        }
        return resultMetadataList;
    }
    getMetadataForKey(model, key) {
        return this.getMetadata(model).find(([metaKey]) => (0, core_1.isSamePath)(metaKey, key));
    }
    addMetadata(model, metadata) {
        var _a, _b;
        // Get metadata on the model
        const exists = (_a = this.storage.get(model)) !== null && _a !== void 0 ? _a : [];
        // Get metadata on prototype
        const protoExists = (_b = this.storage.get(Object.getPrototypeOf(model))) !== null && _b !== void 0 ? _b : [];
        // merged existing metadata
        const merged = [...protoExists, ...exists];
        // if already exists, break
        if (merged.some(([existKey]) => (0, core_1.isSamePath)(existKey, metadata[0]))) {
            return;
        }
        this.storage.set(model, [...merged, metadata]);
    }
    has(metaKey) {
        return this.storage.has(metaKey);
    }
    dispose() {
        this.storage = new WeakMap();
    }
}
exports.ClassMetadataStorage = ClassMetadataStorage;
//# sourceMappingURL=class-metadata.storage.js.map