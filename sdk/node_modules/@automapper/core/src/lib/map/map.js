"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapArray = exports.mapMutate = exports.mapReturn = void 0;
const utils_1 = require("../utils");
const map_member_1 = require("./map-member");
const assert_unmapped_properties_1 = require("./assert-unmapped-properties");
function setMemberMutateFn(destinationObj) {
    return (destinationMember) => (value) => {
        if (value !== undefined) {
            (0, utils_1.setMutate)(destinationObj, destinationMember, value);
        }
    };
}
function getMemberMutateFn(destinationObj) {
    return (memberPath) => (0, utils_1.get)(destinationObj, memberPath);
}
function setMemberReturnFn(destinationMemberPath, destination) {
    return (value) => {
        destination = (0, utils_1.set)(destination, destinationMemberPath, value);
    };
}
/**
 *
 * @param {TSource} sourceObj - the source object
 * @param {Mapping} mapping - the Mapping object of source <> destination
 * @param {MapOptions} options - options used for this particular map operation
 * @param {Mapper} mapper - the mapper instance
 * @param {ErrorHandler} errorHandler - the error handler
 * @param {boolean} [isMapArray = false] - whether the map operation is in Array mode
 */
function mapReturn(sourceObj, mapping, options, mapper, errorHandler, isMapArray = false) {
    return map({
        sourceObj,
        mapping,
        options,
        mapper,
        errorHandler,
        setMemberFn: setMemberReturnFn,
        isMapArray,
    });
}
exports.mapReturn = mapReturn;
/**
 *
 * @param {TSource} sourceObj - the source object
 * @param {Mapping} mapping - the Mapping object of source <> destination
 * @param {MapOptions} options - options used for this particular map operation
 * @param {Mapper} mapper - the mapper instance
 * @param {ErrorHandler} errorHandler - the error handler
 * @param {TDestination} destinationObj - the destination obj to be mutated
 */
function mapMutate(sourceObj, mapping, options, mapper, errorHandler, destinationObj) {
    map({
        sourceObj,
        mapping,
        options,
        mapper,
        errorHandler,
        setMemberFn: setMemberMutateFn(destinationObj),
        getMemberFn: getMemberMutateFn(destinationObj),
    });
}
exports.mapMutate = mapMutate;
/**
 *
 * @param {TSource} sourceObj - the source object
 * @param {Mapping} mapping - the Mapping object of source <> destination
 * @param {MapOptions} options - options used for this particular map operation
 * @param {Mapper} mapper - the mapper instance
 * @param {ErrorHandler} errorHandler - the error handler
 * @param {Function} setMemberFn
 * @param {Function} getMemberFn
 * @param {boolean} [isMapArray = false] - whether the map operation is in Array mode
 */
function map({ sourceObj, mapping, options, mapper, errorHandler, setMemberFn, getMemberFn, isMapArray = false, }) {
    // destructure the mapping
    const [[, destination], [sourceKey, destinationKey], propsToMap, [mappingBeforeAction, mappingAfterAction],] = mapping;
    // initialize an array of keys that have already been configured
    const configuredKeys = [];
    // deconstruct MapOptions
    const { beforeMap: mapBeforeAction, afterMap: mapAfterAction, extraArguments, } = options !== null && options !== void 0 ? options : {};
    // Before Map
    // Do not run before map when in Map Array mode
    if (!isMapArray) {
        const beforeMap = mapBeforeAction !== null && mapBeforeAction !== void 0 ? mapBeforeAction : mappingBeforeAction;
        if (beforeMap) {
            beforeMap(sourceObj, destination);
        }
    }
    // map
    for (let i = 0, propsLen = propsToMap.length; i < propsLen; i++) {
        // Destructure a props on Mapping which is [propertyKey, MappingProperty, nested?]
        const [destinationMemberPath, [, [transformationMapFn, isMetadataNull = false, [transformationPreCondPredicate, preCondDefaultValue = undefined,] = [],],], [nestedDestinationMemberKey, nestedSourceMemberKey] = [],] = propsToMap[i];
        // Setup a shortcut function to set destinationMemberPath on destination with value as argument
        const setMember = (valFn) => {
            var _a, _b;
            try {
                const val = valFn();
                return setMemberFn(destinationMemberPath, destination)(val);
            }
            catch (originalError) {
                const errorMessage = `
Error at "${destinationMemberPath}" on ${typeof destination === 'string'
                    ? destination
                    : (_b = (_a = destination['prototype']) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name} (${JSON.stringify(destination)})
---------------------------------------------------------------------
Original error: ${originalError}`;
                errorHandler.handle(errorMessage);
                throw new Error(errorMessage);
            }
        };
        // This destination key is being configured. Push to configuredKeys array
        configuredKeys.push(destinationMemberPath[0]);
        // Pre Condition check
        if (transformationPreCondPredicate &&
            !transformationPreCondPredicate(sourceObj)) {
            setMember(() => preCondDefaultValue);
            continue;
        }
        // Start with all the mapInitialize
        if (transformationMapFn[0 /* type */] ===
            6 /* MapInitialize */) {
            const mapInitializedValue = transformationMapFn[1 /* fn */](sourceObj);
            // if null/undefined
            // if isDate, isFile
            // if metadata is null, treat as-is
            if (mapInitializedValue == null ||
                mapInitializedValue instanceof Date ||
                Object.prototype.toString.call(mapInitializedValue).slice(8, -1) ===
                    'File' ||
                isMetadataNull) {
                setMember(() => mapInitializedValue);
                continue;
            }
            // if isArray
            if (Array.isArray(mapInitializedValue)) {
                const [first] = mapInitializedValue;
                // if first item is a primitive
                if (typeof first !== 'object' || first instanceof Date) {
                    setMember(() => mapInitializedValue.slice());
                    continue;
                }
                // if first is empty
                if ((0, utils_1.isEmpty)(first)) {
                    setMember(() => []);
                    continue;
                }
                setMember(() => mapArray(mapInitializedValue, nestedDestinationMemberKey, nestedSourceMemberKey, { extraArguments }, mapper, errorHandler));
                continue;
            }
            // if is object
            if (typeof mapInitializedValue === 'object') {
                const nestedMapping = mapper.getMapping(nestedSourceMemberKey, nestedDestinationMemberKey);
                (0, utils_1.mappingNullCheck)(nestedMapping, errorHandler, nestedSourceMemberKey, nestedDestinationMemberKey);
                // nested mutate
                const destinationMemberValue = getMemberFn === null || getMemberFn === void 0 ? void 0 : getMemberFn(destinationMemberPath);
                if (destinationMemberValue !== undefined) {
                    map({
                        sourceObj: mapInitializedValue,
                        mapping: nestedMapping,
                        options: { extraArguments },
                        mapper,
                        errorHandler,
                        setMemberFn: setMemberMutateFn(destinationMemberValue),
                        getMemberFn: getMemberMutateFn(destinationMemberValue),
                    });
                    continue;
                }
                // for nested model, we do not care about mutate or return. we will always need to return
                setMember(() => map({
                    sourceObj: mapInitializedValue,
                    mapping: nestedMapping,
                    options: { extraArguments },
                    mapper,
                    errorHandler,
                    setMemberFn: setMemberReturnFn,
                }));
                continue;
            }
            // if is primitive
            setMember(() => mapInitializedValue);
            continue;
        }
        setMember(() => (0, map_member_1.mapMember)(transformationMapFn, sourceObj, destination, destinationMemberPath, extraArguments, mapper));
    }
    // After map
    // Do not run for when in Map Array mode
    if (!isMapArray) {
        const afterMap = mapAfterAction !== null && mapAfterAction !== void 0 ? mapAfterAction : mappingAfterAction;
        if (afterMap) {
            afterMap(sourceObj, destination);
        }
    }
    // Check unmapped properties
    (0, assert_unmapped_properties_1.assertUnmappedProperties)(destination, configuredKeys, sourceKey, destinationKey, errorHandler);
    return destination;
}
/**
 *
 * @param {TSource[]} sourceArray - the array of source items to map
 * @param destination - destination meta key
 * @param source - source meta key
 * @param {MapArrayOptions} options - the map options for this particular map operation
 * @param {Mapper} mapper - the mapper instance
 * @param {ErrorHandler} errorHandler - error handler
 */
function mapArray(sourceArray, destination, source, options, mapper, errorHandler) {
    // initialize an empty array
    const destinationArray = [];
    // destructure mapOptions
    const { beforeMap, afterMap, extraArguments } = options !== null && options !== void 0 ? options : {};
    // run beforeMap for the whole map operation
    if (beforeMap) {
        beforeMap(sourceArray, []);
    }
    // loop through each item and run map() for each
    for (let i = 0, len = sourceArray.length; i < len; i++) {
        const mapping = mapper.getMapping(source, destination);
        (0, utils_1.mappingNullCheck)(mapping, errorHandler, source, destination);
        destinationArray.push(mapReturn(sourceArray[i], mapping, { extraArguments }, mapper, errorHandler, true));
    }
    // run afterMap for the whole map operation
    if (afterMap) {
        afterMap(sourceArray, destinationArray);
    }
    return destinationArray;
}
exports.mapArray = mapArray;
//# sourceMappingURL=map.js.map