"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMemberPath = exports.getMembers = void 0;
const PROXY_TARGET = () => undefined;
const PROXY_OBJECT = createProxy(PROXY_TARGET);
/**
 * For a given JS function selector, return a list of all members that were selected.
 *
 * @returns `null` if the given `fnSelector` doesn't match with anything.
 */
function getMembers(fnSelector) {
    const resultProxy = fnSelector(PROXY_OBJECT);
    if (typeof resultProxy !== 'function') {
        return null;
    }
    const members = resultProxy();
    if (members.length === 0 || members.some((m) => typeof m !== 'string')) {
        return null;
    }
    return members;
}
exports.getMembers = getMembers;
/**
 * Get a dot-separated string of the properties selected by a given `fn` selector
 * function.
 *
 * @example
 * ```js
 * getMemberPath(s => s.foo.bar) === 'foo.bar'
 * getMemberPath(s => s['foo']) === 'foo'
 * getMemberPath(s => s.foo['']) === 'foo.'
 * // invalid usage
 * getMemberPath(s => s) === ''
 * ```
 */
function getMemberPath(fn) {
    const members = getMembers(fn);
    return members ? members : [];
}
exports.getMemberPath = getMemberPath;
/**
 * @returns {Proxy} A proxy that's wrap on the target object and track of
 * the path of accessed nested properties
 */
function createProxy(target, path = []) {
    const realTraps = {
        get(target, p) {
            const childPath = path.slice();
            childPath.push(p);
            return createProxy(PROXY_TARGET, childPath);
        },
        apply() {
            return path;
        },
    };
    return new Proxy(target, realTraps);
}
//# sourceMappingURL=get-member-path.util.js.map