"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMapForMember = void 0;
const utils_1 = require("../utils");
const get_member_path_util_1 = require("./get-member-path.util");
/**
 *
 * @param {Mapping} mapping - Mapping between source <> destination
 * @param {Selector} selector - the member selector on `forMember(selector)`
 * @param preCondOrMapMemberFn
 * @param mapMemberFn
 */
function createMapForMember(mapping, selector, [preCondOrMapMemberFn, mapMemberFn]) {
    // get the memberPath from the selector
    // eg: `s => s.foo.bar` returns `foo.bar`
    const memberPath = (0, get_member_path_util_1.getMemberPath)(selector);
    // reassign mapMemberFn and preCond
    if (mapMemberFn == null) {
        mapMemberFn = preCondOrMapMemberFn;
        preCondOrMapMemberFn = undefined;
    }
    // initialize sourcePath
    let sourcePath = [];
    // if the transformation is MapWith, we have information on the source value selector
    if (mapMemberFn[0 /* type */] === 4 /* MapWith */ &&
        mapMemberFn[2 /* misc */] != null) {
        sourcePath = (0, get_member_path_util_1.getMemberPath)(mapMemberFn[2 /* misc */]);
    }
    // initialize MappingProperty
    const mappingProperty = [
        [memberPath, sourcePath],
        [mapMemberFn, false, preCondOrMapMemberFn],
    ];
    // check existProp on mapping
    const existProp = mapping[2 /* properties */].find(([propName]) => (0, utils_1.isSamePath)(propName, memberPath));
    // if exists, overrides
    if (existProp != null) {
        existProp[1 /* property */] = mappingProperty;
    }
    else {
        // push MappingProperty to mapping
        mapping[2 /* properties */].push([memberPath, mappingProperty]);
    }
}
exports.createMapForMember = createMapForMember;
//# sourceMappingURL=create-map-for-member.util.js.map