"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMapper = void 0;
const map_1 = require("../map");
const create_map_fluent_function_util_1 = require("./create-map-fluent-function.util");
const utils_1 = require("../utils");
const apply_type_converters_util_1 = require("./apply-type-converters.util");
/**
 * Method to create a Mapper with a plugin
 *
 * @param {CreateMapperOptions} createMapperOptions - options for createMapper
 */
function createMapper({ name, pluginInitializer, namingConventions, errorHandler: customErrorHandler, }) {
    // default errorHandler to console.error
    const errorHandler = customErrorHandler || { handle: console.error };
    // get the plugin
    const plugin = pluginInitializer(errorHandler);
    // type converters
    const typeConverters = new Map();
    return {
        name,
        plugin,
        addTypeConverter(source, destination, converter) {
            const sourceTypeConverters = typeConverters.get(source);
            if (sourceTypeConverters) {
                sourceTypeConverters.set(destination, converter);
                return this;
            }
            typeConverters.set(source, new Map([
                [destination, converter],
            ]));
            return this;
        },
        createMap(source, destination, options = {}) {
            // if namingConventions isn't passed in for this Mapping pair, use the global ones
            if (options && !options.namingConventions) {
                options.namingConventions = namingConventions;
            }
            // create the initial mapping between source and destination
            const mapping = plugin.initializeMapping(source, destination, options);
            if (mapping) {
                mapping[4 /* mapper */] = this;
                // apply typeConverters
                (0, apply_type_converters_util_1.applyTypeConverters)(mapping, typeConverters);
            }
            // return the FluentFunction for chaining
            return (0, create_map_fluent_function_util_1.createMapFluentFunction)(mapping);
        },
        getMapping: plugin.getMapping.bind(plugin),
        addProfile(profile) {
            profile(this);
            return this;
        },
        map(sourceObj, destination, source, destinationObjOrOptions, options) {
            // if source is null/undefined, return
            if (sourceObj == null) {
                return sourceObj;
            }
            const { preMap, postMap } = plugin;
            // run preMap if available
            const [sourceInstance] = preMap
                ? preMap.apply(plugin, [source, destination, sourceObj])
                : [sourceObj];
            // get mapping between Source and Destination
            const mapping = this.getMapping(source, destination);
            // null check mapping and fail fast
            (0, utils_1.mappingNullCheck)(mapping, errorHandler, source, destination);
            // check mutate or return
            // if destinationObjOrOptions has beforeMap or afterMap
            // or destinationObjOrOptions is null/undefined => this is a mapReturn
            // TODO(chau): this might fail if destinationObj has a beforeMap/afterMap property on the consumer side.
            if ((destinationObjOrOptions &&
                ('beforeMap' in destinationObjOrOptions ||
                    'afterMap' in destinationObjOrOptions ||
                    'extraArguments' in destinationObjOrOptions)) ||
                destinationObjOrOptions == null) {
                const result = (0, map_1.mapReturn)(sourceInstance, mapping, destinationObjOrOptions, this, errorHandler);
                if (postMap) {
                    return postMap.apply(plugin, [destination, result]);
                }
                return result;
            }
            (0, map_1.mapMutate)(sourceInstance, mapping, options || {}, this, errorHandler, destinationObjOrOptions);
            if (postMap) {
                destinationObjOrOptions = postMap(destination, destinationObjOrOptions);
            }
        },
        mapAsync(sourceObj, destination, source, destinationObjOrOptions, options) {
            return Promise.resolve(this.map(sourceObj, destination, source, destinationObjOrOptions, options));
        },
        mapArray(sourceArr, destination, source, options) {
            // if source is null/undefined, return
            if (sourceArr == null) {
                return sourceArr;
            }
            // default runPreMap to true
            const { runPreMap = true } = options || {};
            // run preMapArray if available
            if (runPreMap && plugin.preMapArray) {
                sourceArr = plugin.preMapArray.apply(plugin, [source, sourceArr]);
            }
            return (0, map_1.mapArray)(sourceArr, destination, source, options || {}, this, errorHandler);
        },
        mapArrayAsync(sourceArr, destination, source, options) {
            return Promise.resolve(this.mapArray(sourceArr, destination, source, options));
        },
        dispose() {
            if (plugin.dispose) {
                plugin.dispose();
            }
        },
    };
}
exports.createMapper = createMapper;
//# sourceMappingURL=create-mapper.js.map