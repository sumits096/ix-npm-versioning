"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInitialMapping = void 0;
const utils_1 = require("../utils");
const extend_mappings_util_1 = require("./extend-mappings.util");
const get_flattening_source_paths_util_1 = require("./get-flattening-source-paths.util");
const get_naming_conventions_from_options_util_1 = require("./get-naming-conventions-from-options.util");
const get_nested_metakey_at_destination_path_util_1 = require("./get-nested-metakey-at-destination-path.util");
const get_path_recursive_util_1 = require("./get-path-recursive.util");
const get_source_property_path_util_1 = require("./get-source-property-path.util");
const map_initialize_1 = require("./map-initialize");
function defaultIsMultipartSourcePathsInSource(multipartSourcePaths, sourceObj) {
    return !(multipartSourcePaths.length > 1 &&
        (!sourceObj.hasOwnProperty(multipartSourcePaths[0]) ||
            (sourceObj[multipartSourcePaths[0]] &&
                typeof sourceObj[multipartSourcePaths[0]] === 'object')));
}
function defaultIsDerivedSourcePathOnSource(sourceObj, sourcePath) {
    return sourcePath.length === 1 && sourceObj.hasOwnProperty(sourcePath[0]);
}
function createInitialMapping(sourceObj, destinationObj, sourceNestedMetadataMap, destinationNestedMetadataMap, saveMapping, options, createInitialMappingOptions) {
    const { isMultipartSourcePathsInSource = defaultIsMultipartSourcePathsInSource, isDerivedSourcePathOnSource = defaultIsDerivedSourcePathOnSource, isMetadataNullAtKey = () => false, prePropertiesLoop, } = createInitialMappingOptions !== null && createInitialMappingOptions !== void 0 ? createInitialMappingOptions : {};
    const { extends: bases = [], namingConventions: conventions } = options !== null && options !== void 0 ? options : {};
    const mapping = [
        [sourceObj, destinationObj],
        [null, null],
        [],
        [],
        undefined,
        (0, get_naming_conventions_from_options_util_1.getNamingConventionsFromOptions)(conventions),
        undefined,
    ];
    if (prePropertiesLoop) {
        prePropertiesLoop(mapping);
    }
    const destinationPaths = (0, get_path_recursive_util_1.getPathRecursive)(destinationObj) || [];
    const namingConventions = mapping[5 /* namingConventions */];
    for (let i = 0, destinationPathsLen = destinationPaths.length; i < destinationPathsLen; i++) {
        const destinationPath = destinationPaths[i];
        const destinationNestedMetadataAtPath = (0, get_nested_metakey_at_destination_path_util_1.getNestedMetaKeyAtDestinationPath)(destinationNestedMetadataMap, sourceNestedMetadataMap, destinationPath, namingConventions);
        const sourcePath = (0, get_source_property_path_util_1.getSourcePropertyPath)(destinationPath, namingConventions);
        if (!isMultipartSourcePathsInSource(sourcePath, sourceObj)) {
            continue;
        }
        const isMetadataNull = isMetadataNullAtKey(destinationPath);
        // With namingConventions, flattening can happen
        if (!isDerivedSourcePathOnSource(sourceObj, sourcePath) &&
            (0, utils_1.isDefined)(namingConventions)) {
            const sourcePaths = (0, get_flattening_source_paths_util_1.getFlatteningSourcePaths)(sourceObj, sourcePath, namingConventions);
            if (!(0, utils_1.isDefined)(sourcePaths)) {
                continue;
            }
            mapping[2 /* properties */].push([
                destinationPath,
                [[destinationPath], [(0, map_initialize_1.mapInitialize)(sourcePaths), isMetadataNull]],
                destinationNestedMetadataAtPath,
            ]);
            continue;
        }
        // Skip if there's no destinationPath on source
        if (!isDerivedSourcePathOnSource(sourceObj, sourcePath)) {
            continue;
        }
        mapping[2 /* properties */].push([
            destinationPath,
            [
                [destinationPath, sourcePath],
                [(0, map_initialize_1.mapInitialize)(sourcePath), isMetadataNull],
            ],
            destinationNestedMetadataAtPath,
        ]);
    }
    // Inherit base mappings
    if (bases.length) {
        (0, extend_mappings_util_1.extendMappings)(bases, mapping);
    }
    saveMapping(mapping);
    return mapping;
}
exports.createInitialMapping = createInitialMapping;
//# sourceMappingURL=create-initial-mapping.util.js.map